<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML Lite - Simple Machine Learning Training</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- PyScript CSS and JS (2024.1.1) -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    
    <!-- Hide PyScript warnings and output -->
    <style>
        /* Hide PyScript terminal and output elements */
        py-terminal,
        py-output,
        .py-terminal,
        .py-output,
        .pyscript-terminal,
        .pyscript-output,
        .py-console,
        .pyscript-console,
        [data-testid="py-terminal"],
        [data-testid="py-output"],
        py-script + .py-terminal,
        py-script + .py-output,
        /* Hide any PyScript warning elements */
        .py-warning,
        .pyscript-warning,
        .py-error,
        .pyscript-error,
        /* Hide stderr output from PyScript */
        .py-stderr,
        .pyscript-stderr,
        /* Hide PyScript loading messages */
        .py-loading,
        .pyscript-loading {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            width: 0 !important;
            overflow: hidden !important;
        }
    </style>
    
    <!-- PyScript Configuration -->
    <py-config>
        packages = ["pandas", "numpy", "scikit-learn", "matplotlib"]
    </py-config>
</head>
<body>
    <div class="container">
        <div class="content-area">
            <header role="banner">
                <h1 id="app-title">ML Lite</h1>
                <p id="app-description">Simple Machine Learning Model Training</p>
            </header>

            <!-- Vertical Tabs -->
            <div class="tabs-container" role="application" aria-labelledby="app-title" aria-describedby="app-description">
                <div class="tab-navigation" role="tablist" aria-label="Machine Learning Training Steps">
                    <button class="tab-button active" data-tab="model-data" role="tab" aria-selected="true" aria-controls="model-data" id="tab-model-data">
                        <span class="tab-number" aria-hidden="true">1</span>
                        Model Type & Data
                    </button>
                    <button class="tab-button" data-tab="training-settings" disabled role="tab" aria-selected="false" aria-controls="training-settings" id="tab-training-settings" aria-disabled="true">
                        <span class="tab-number" aria-hidden="true">2</span>
                        Training Settings
                    </button>
                    <button class="tab-button" data-tab="training-process" disabled role="tab" aria-selected="false" aria-controls="training-process" id="tab-training-process" aria-disabled="true">
                        <span class="tab-number" aria-hidden="true">3</span>
                        Training Process
                    </button>
                    <button class="tab-button" data-tab="training-results" disabled role="tab" aria-selected="false" aria-controls="training-results" id="tab-training-results" aria-disabled="true">
                        <span class="tab-number" aria-hidden="true">4</span>
                        Training Results
                    </button>
                    <button class="tab-button" data-tab="test" disabled role="tab" aria-selected="false" aria-controls="test" id="tab-test" aria-disabled="true">
                        <span class="tab-number" aria-hidden="true">5</span>
                        Test Model
                    </button>
                    
                    <!-- ML Engine Status -->
                    <div id="ml-engine-status" class="ml-engine-progress-sidebar" role="status" aria-label="Machine Learning Engine Status">
                        <div class="progress-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-describedby="progress-text">
                            <div class="progress-bar" id="progress-bar" aria-hidden="true"></div>
                        </div>
                        <span id="progress-text" aria-live="polite">üîÑ Loading ML Engine...</span>
                    </div>
                </div>

                <div class="tab-content">
                    <!-- Tab 1: Model Type & Data -->
                    <div id="model-data" class="tab-panel active" role="tabpanel" aria-labelledby="tab-model-data">
                        <h2>Model Type & Data</h2>
                        
                        <div class="settings-grid">
                            <div class="section" role="group" aria-labelledby="model-type-heading">
                                <h3 id="model-type-heading">Choose Model Type</h3>
                                <div class="setting-group">
                                    <label for="modelType">Model Type:</label>
                                    <select id="modelType" aria-describedby="modelType-help">
                                        <option value="regression">Regression (Predict numbers)</option>
                                        <option value="classification">Classification (Predict categories)</option>
                                        <option value="clustering">Clustering (Find groups)</option>
                                    </select>
                                    <div id="modelType-help" class="sr-only">Select the type of machine learning model based on your prediction goal</div>
                                </div>
                            </div>

                            <div class="section" role="group" aria-labelledby="data-upload-heading">
                                <h3 id="data-upload-heading">Upload Training Data</h3>
                                <div class="file-upload">
                                    <input type="file" id="dataFile" accept=".csv" aria-describedby="dataFile-help" />
                                    <label for="dataFile" class="file-upload-label">
                                        Choose CSV file...
                                    </label>
                                    <span class="file-name" id="fileName" aria-live="polite">No file chosen</span>
                                    <div id="dataFile-help" class="sr-only">Upload a CSV file containing your training data with headers</div>
                                </div>
                            </div>
                        </div>

                        <div class="section" id="data-preview" style="display: none;" role="region" aria-labelledby="data-preview-heading">
                            <h3 id="data-preview-heading">Data Preview <span style="font-size: 0.8em; color: #666; font-weight: normal;" aria-label="showing first 3 rows">(showing first 3 rows)</span></h3>

                            <div class="table-container">
                                <table id="dataTable" role="table" aria-label="Training data preview">
                                    <!-- Data will be populated here -->
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 2: Training Settings -->
                    <div id="training-settings" class="tab-panel" role="tabpanel" aria-labelledby="tab-training-settings">
                        <h2>Training Settings</h2>
                        
                        <div id="supervised-settings" class="section" role="group" aria-labelledby="target-features-heading">
                            <h3 id="target-features-heading">Target and Features</h3>
                            <div class="form-row">
                                <div class="setting-group">
                                    <label for="targetColumn">Target column (label to predict):</label>
                                    <select id="targetColumn" aria-describedby="targetColumn-help">
                                        <option value="">Select target column...</option>
                                    </select>
                                    <div id="targetColumn-help" class="sr-only">Choose the column you want the model to predict</div>
                                </div>
                            </div>

                            <div class="setting-group">
                                <label id="featureColumns-label">Feature Columns:</label>
                                <div id="featureColumns" class="checkbox-group" role="group" aria-labelledby="featureColumns-label" aria-describedby="featureColumns-help">
                                    <!-- Feature checkboxes will be populated here -->
                                </div>
                                <div id="featureColumns-help" class="sr-only">Select the columns to use as input features for training the model</div>
                            </div>
                        </div>

                        <div id="clustering-settings" class="section" style="display: none;" role="group" aria-labelledby="clustering-heading">
                            <h3 id="clustering-heading">Clustering Settings</h3>
                            <div class="setting-group">
                                <label id="clusteringFeatures-label">Feature Columns:</label>
                                <div id="clusteringFeatures" class="checkbox-group" role="group" aria-labelledby="clusteringFeatures-label" aria-describedby="clusteringFeatures-help">
                                    <!-- Feature checkboxes will be populated here -->
                                </div>
                                <div id="clusteringFeatures-help" class="sr-only">Select the columns to use for clustering analysis</div>
                            </div>

                            <div class="form-row">
                                <div class="setting-group">
                                    <fieldset>
                                        <legend>Number of Clusters:</legend>
                                        <div class="radio-group" role="radiogroup" aria-describedby="cluster-method-help">
                                            <label>
                                                <input type="radio" name="clusterMethod" value="auto" checked aria-describedby="auto-cluster-help">
                                                Automatic (find optimal)
                                            </label>
                                            <label>
                                                <input type="radio" name="clusterMethod" value="manual" aria-describedby="manual-cluster-help">
                                                Manual selection
                                            </label>
                                        </div>
                                        <div id="cluster-method-help" class="sr-only">Choose how to determine the number of clusters</div>
                                        <div id="auto-cluster-help" class="sr-only">Let the algorithm find the optimal number of clusters</div>
                                        <div id="manual-cluster-help" class="sr-only">Specify the exact number of clusters</div>
                                    </fieldset>
                                </div>

                                <div id="manual-clusters" class="setting-group" style="display: none;">
                                    <label for="numClusters">Number of clusters:</label>
                                    <input type="number" id="numClusters" value="3" min="2" max="10" aria-describedby="numClusters-help">
                                    <div id="numClusters-help" class="sr-only">Enter the number of clusters to create (between 2 and 10)</div>
                                </div>
                            </div>
                        </div>

                        <div class="section" role="group" aria-labelledby="training-params-heading">
                            <h3 id="training-params-heading">Training Parameters</h3>
                            <div class="form-row">
                                <div id="train-split-container" class="setting-group">
                                    <label for="trainSplit">Training/Testing split:</label>
                                    <div class="split-control">
                                        <span aria-hidden="true">0%</span>
                                        <input type="range" id="trainSplit" min="0" max="100" value="70" step="5" 
                                               aria-describedby="splitDisplay trainSplit-help" 
                                               aria-label="Training and testing data split percentage">
                                        <span aria-hidden="true">100%</span>
                                    </div>
                                    <div id="splitDisplay" class="split-display" aria-live="polite">70% training / 30% testing</div>
                                    <div id="trainSplit-help" class="sr-only">Adjust the percentage of data used for training versus testing the model</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 3: Training Process -->
                    <div id="training-process" class="tab-panel" role="tabpanel" aria-labelledby="tab-training-process">
                        <h2>Training Process</h2>
                        
                        <!-- Configuration Summary -->
                        <div class="section" role="region" aria-labelledby="config-summary-heading">
                            <h3 id="config-summary-heading">Configuration Summary</h3>
                            <div id="configSummary" aria-live="polite">
                                <!-- Configuration will be populated here -->
                            </div>
                        </div>
                        
                        <div class="training-controls">
                            <button id="startTraining" class="primary-button" aria-describedby="start-training-help">Start Training</button>
                            <div id="start-training-help" class="sr-only">Begin training the machine learning model with your data and settings</div>
                        </div>

                        <div id="training-progress" style="display: none;" role="region" aria-labelledby="training-progress-heading">
                            <h3 id="training-progress-heading">Training Progress</h3>
                            <div class="single-progress-container">
                                <div class="progress-bar-wrapper" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-describedby="progressText progressPercentage">
                                    <div class="progress-bar-fill" id="trainingProgressBar" aria-hidden="true"></div>
                                </div>
                                <div class="progress-text" id="progressText" aria-live="polite">Initializing...</div>
                                <div class="progress-percentage" id="progressPercentage" aria-live="polite">0%</div>
                            </div>
                            
                            <div id="training-log" role="region" aria-labelledby="training-log-heading">
                                <div class="log-header">
                                    <h4 id="training-log-heading">Training Log</h4>
                                    <div class="log-buttons">
                                        <button id="saveModelButton" class="toggle-btn secondary-button" style="display: none;" aria-describedby="save-model-help">Save Model</button>
                                        <button id="toggleLogBtn" class="toggle-btn" onclick="toggleTrainingLog()" aria-expanded="false" aria-controls="logContent" aria-describedby="toggle-log-help">
                                            <span id="logToggleIcon" aria-hidden="true">‚ñº</span> Show Details
                                        </button>
                                    </div>
                                    <div id="toggle-log-help" class="sr-only">Toggle visibility of detailed training log information</div>
                                    <div id="save-model-help" class="sr-only">Download the trained model for use in your own applications</div>
                                </div>
                                <div id="logContent" class="log-content collapsed" aria-labelledby="training-log-heading">
                                    <pre id="progressLog" role="log" aria-live="polite" aria-label="Training progress log"></pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 4: Training Results -->
                    <div id="training-results" class="tab-panel" role="tabpanel" aria-labelledby="tab-training-results">
                        <h2>Training Results</h2>
                        
                        <div id="results-content" style="display: none;" role="region" aria-labelledby="results-heading">
                            <!-- Metrics Cards Section -->
                            <div class="section" role="region" aria-labelledby="metrics-heading">
                                <h3 id="metrics-heading">Model Performance</h3>
                                <div id="metrics-display" class="horizontal-metrics" role="list" aria-label="Performance metrics">
                                    <!-- Metrics will be populated here as horizontal cards -->
                                </div>
                            </div>

                            <!-- Visualization Section (larger) -->
                            <div class="section" role="region" aria-labelledby="visualization-heading">
                                <h3 id="visualization-heading">Visualization</h3>
                                <div id="training-chart" class="large-visualization" role="img" aria-label="Training results visualization chart">
                                    <!-- Chart will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 5: Test Model -->
                    <div id="test" class="tab-panel" role="tabpanel" aria-labelledby="tab-test">
                        <h2>Test Your Model</h2>
                        
                        <div id="prediction-interface" style="display: none;" role="region" aria-labelledby="prediction-interface-heading">
                            <div class="test-layout-grid">
                                <div class="test-inputs-column">
                                    <h3 id="prediction-interface-heading">Enter Values for Prediction</h3>
                                    <div id="prediction-inputs" class="prediction-inputs-vertical" role="form" aria-labelledby="prediction-interface-heading">
                                        <!-- Input fields will be populated here -->
                                    </div>
                                    
                                    <div class="test-button-container">
                                        <button id="makePrediction" class="primary-button" aria-describedby="make-prediction-help">Make Prediction</button>
                                        <div id="make-prediction-help" class="sr-only">Use the trained model to make a prediction based on the entered values</div>
                                    </div>
                                </div>
                                
                                <div class="test-results-column">
                                    <div id="prediction-result" style="display: none;" role="region" aria-labelledby="prediction-result-heading">
                                        <h3 id="prediction-result-heading">Prediction Result</h3>
                                        <div id="prediction-output" aria-live="polite"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="no-model-message" role="alert">
                            <p>No trained model available. Please train a model first.</p>
                        </div>
                    </div>

                    <!-- Navigation buttons -->
                    <div class="tab-navigation-buttons" role="navigation" aria-label="Step navigation">
                        <div class="nav-buttons-container">
                            <button id="prevButton" class="nav-button" disabled aria-describedby="prev-button-help">Previous</button>
                            <button id="nextButton" class="nav-button" disabled aria-describedby="next-button-help">Next</button>
                            <div class="right-buttons-group">
                                <div id="prev-button-help" class="sr-only">Go to the previous step in the training process</div>
                                <div id="next-button-help" class="sr-only">Go to the next step in the training process</div>
                                <button id="trainAnotherButton" class="nav-button primary-button" style="display: none;" aria-describedby="train-another-help">Train Another Model</button>
                                <div id="train-another-help" class="sr-only">Start over and train a new machine learning model with different data or settings</div>
                            </div>
                        </div>
                    </div>
                </div>

                
            </div>
        </div>
    </div>

    <!-- Load JavaScript -->
    <script src="script.js"></script>

    <!-- PyScript with ML functionality -->
    <py-script>
        # PyScript initialization
        import warnings
        import pandas as pd
        import numpy as np
        from io import StringIO
        import json
        import js
        
        # Suppress threadpoolctl warnings in PyScript/browser environment
        warnings.filterwarnings('ignore', message='.*libc not found.*')
        warnings.filterwarnings('ignore', category=RuntimeWarning, module='threadpoolctl')
        
        print("PyScript starting...")
        print("‚úì Basic libraries imported")
        
        # Import ML libraries at module level
        try:
            from sklearn.model_selection import train_test_split
            from sklearn.preprocessing import StandardScaler, LabelEncoder
            from sklearn.linear_model import LinearRegression, LogisticRegression
            from sklearn.cluster import KMeans
            from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, accuracy_score, precision_score, recall_score, f1_score, confusion_matrix, silhouette_score
            from sklearn.decomposition import PCA
            import matplotlib.pyplot as plt
            import io
            import base64
            print("‚úì ML libraries imported successfully")
        except Exception as e:
            print(f"‚ùå Failed to import ML libraries: {e}")
            raise e
        
        # Global storage for trained model
        trained_model = None
        model_info = {}
        
        def train_model_simple(csv_content, has_headers, model_type, target_column, feature_columns, train_split, cluster_method=None, num_clusters=None):
            import json  # Import json for this function
            global trained_model, model_info
            print(f"Training {model_type} model...")
            print(f"Parameters received:")
            print(f"  csv_content type: {type(csv_content)}, length: {len(csv_content) if csv_content else 'None'}")
            print(f"  has_headers: {has_headers} (type: {type(has_headers)})")
            print(f"  model_type: {model_type} (type: {type(model_type)})")
            print(f"  target_column: {target_column} (type: {type(target_column)})")
            print(f"  feature_columns: {feature_columns} (type: {type(feature_columns)})")
            print(f"  train_split: {train_split} (type: {type(train_split)})")
            if cluster_method is not None:
                print(f"  cluster_method: {cluster_method} (type: {type(cluster_method)})")
            if num_clusters is not None:
                print(f"  num_clusters: {num_clusters} (type: {type(num_clusters)})")
            
            # Validate parameters
            if not csv_content:
                return json.dumps({'success': False, 'error': 'No CSV content provided'})
            if not model_type:
                return json.dumps({'success': False, 'error': 'No model type specified'})
            if not target_column and model_type in ['regression', 'classification']:
                return json.dumps({'success': False, 'error': 'Target column required for supervised learning'})
            if not feature_columns:
                return json.dumps({'success': False, 'error': 'No feature columns specified'})
            
            try:
                print(f"Raw CSV content preview (first 500 chars): '{csv_content[:500]}'")
                
                # First, try to detect if we actually have headers
                lines = csv_content.strip().split('\n')
                if len(lines) < 2:
                    return json.dumps({'success': False, 'error': 'CSV file must have at least 2 rows'})
                
                first_row = lines[0].split(',')
                second_row = lines[1].split(',') if len(lines) > 1 else []
                
                print(f"First row: {first_row}")
                print(f"Second row: {second_row}")
                
                # Simple heuristic: if first row contains mostly numeric data, it's probably not headers
                def looks_like_header(row):
                    if not row:
                        return False
                    # Check if most values are non-numeric (likely headers)
                    non_numeric_count = 0
                    for val in row:
                        val = val.strip()
                        try:
                            float(val)
                        except (ValueError, TypeError):
                            if val and not val.replace('.', '').replace('-', '').isdigit():
                                non_numeric_count += 1
                    return non_numeric_count > len(row) / 2
                
                has_actual_headers = looks_like_header(first_row)
                print(f"Header detection: {has_actual_headers}")
                
                # Parse CSV based on actual header detection
                if has_actual_headers:
                    df = pd.read_csv(StringIO(csv_content))
                    print("Parsed with headers")
                else:
                    # No headers, use generic column names
                    df = pd.read_csv(StringIO(csv_content), header=None)
                    # Create generic column names
                    df.columns = [f'Column_{i+1}' for i in range(len(df.columns))]
                    print(f"No headers detected, created generic columns: {list(df.columns)}")
                    # Return error asking user to add headers
                    return json.dumps({
                        'success': False, 
                        'error': 'CSV file appears to have no headers. Please ensure the first row contains column names like: Date,DayOfWeek,Month,Temperature,Rainfall,IceCreamsSold'
                    })
                    
                print(f"‚úì Data loaded: {df.shape[0]} rows, {df.shape[1]} columns")
                print(f"‚úì DataFrame dtypes:")
                for col, dtype in df.dtypes.items():
                    print(f"    '{col}': {dtype}")
                print(f"‚úì Actual column names in DataFrame: {list(df.columns)}")
                print(f"‚úì Column names (repr): {[repr(col) for col in df.columns]}")
                print(f"‚úì Requested target column: '{target_column}' (repr: {repr(target_column)})")
                print(f"‚úì Requested feature columns: {feature_columns}")
                print(f"‚úì Feature columns (repr): {[repr(col) for col in feature_columns]}")
                
                # Clean column names (remove any whitespace/special chars)
                df.columns = df.columns.str.strip()
                print(f"‚úì Cleaned column names: {list(df.columns)}")
                
                # Check if requested columns exist
                missing_cols = []
                if target_column and target_column.strip() not in df.columns:
                    missing_cols.append(f"target: '{target_column}'")
                for col in feature_columns:
                    if col.strip() not in df.columns:
                        missing_cols.append(f"feature: '{col}'")
                
                if missing_cols:
                    error_msg = f"Column(s) not found in data: {', '.join(missing_cols)}"
                    print(f"‚ùå {error_msg}")
                    return json.dumps({'success': False, 'error': error_msg})
                
                # Initialize scaler variable
                model_scaler = None
                
                if model_type in ['regression', 'classification']:
                    # Supervised learning - use cleaned column names
                    target_clean = target_column.strip()
                    features_clean = [col.strip() for col in feature_columns]
                    
                    X = df[features_clean]
                    y = df[target_clean]
                    
                    # Handle missing values and encode categorical variables
                    X_processed = X.copy()
                    for col in X_processed.columns:
                        if X_processed[col].dtype == 'object':
                            le = LabelEncoder()
                            X_processed[col] = le.fit_transform(X_processed[col].astype(str))
                        else:
                            X_processed[col] = pd.to_numeric(X_processed[col], errors='coerce').fillna(X_processed[col].median())
                    
                    # Handle target variable
                    if model_type == 'classification' or y.dtype == 'object':
                        le_target = LabelEncoder()
                        y_processed = le_target.fit_transform(y.astype(str))
                    else:
                        y_processed = pd.to_numeric(y, errors='coerce').fillna(y.median())
                    
                    # Split data
                    X_train, X_test, y_train, y_test = train_test_split(
                        X_processed, y_processed, test_size=(1-train_split), random_state=42
                    )
                    
                    # Ensure we have enough data for meaningful metrics
                    if len(X_test) < 2:
                        print("Warning: Test set too small, using larger split")
                        X_train, X_test, y_train, y_test = train_test_split(
                            X_processed, y_processed, test_size=0.3, random_state=42
                        )
                    
                    # Train model
                    if model_type == 'regression':
                        model = LinearRegression()
                        model.fit(X_train, y_train)
                        y_pred = model.predict(X_test)
                        
                        # Calculate regression metrics with error handling
                        try:
                            r2 = r2_score(y_test, y_pred) if len(y_test) > 1 else 0.0
                        except:
                            r2 = 0.0
                            
                        metrics = {
                            'mae': round(mean_absolute_error(y_test, y_pred), 3),
                            'mse': round(mean_squared_error(y_test, y_pred), 3),
                            'rmse': round(np.sqrt(mean_squared_error(y_test, y_pred)), 3),
                            'r2': round(r2, 3)
                        }
                        
                        # Create regression plot
                        plt.figure(figsize=(10, 8))
                        plt.scatter(y_test, y_pred, alpha=0.6, color='#0078d4')
                        min_val = min(min(y_test), min(y_pred))
                        max_val = max(max(y_test), max(y_pred))
                        plt.plot([min_val, max_val], [min_val, max_val], 'r--', lw=2, label='Perfect Predictions')
                        plt.xlabel('Actual Values')
                        plt.ylabel('Predicted Values')
                        plt.title('Regression Results: Predicted vs Actual')
                        plt.legend()
                        plt.grid(True, alpha=0.3)
                        
                    else:  # classification
                        model = LogisticRegression(random_state=42, max_iter=1000)
                        model.fit(X_train, y_train)
                        y_pred = model.predict(X_test)
                        
                        # Calculate classification metrics
                        metrics = {
                            'accuracy': round(accuracy_score(y_test, y_pred), 3),
                            'precision': round(precision_score(y_test, y_pred, average='weighted', zero_division=0), 3),
                            'recall': round(recall_score(y_test, y_pred, average='weighted', zero_division=0), 3),
                            'f1': round(f1_score(y_test, y_pred, average='weighted', zero_division=0), 3)
                        }
                        
                        # Create confusion matrix
                        cm = confusion_matrix(y_test, y_pred)
                        plt.figure(figsize=(8, 6))
                        plt.imshow(cm, interpolation='nearest', cmap='Blues')
                        plt.title('Confusion Matrix')
                        plt.colorbar()
                        
                        # Add text annotations
                        for i in range(cm.shape[0]):
                            for j in range(cm.shape[1]):
                                plt.text(j, i, str(cm[i, j]), ha='center', va='center', 
                                        color='white' if cm[i, j] > cm.max() / 2 else 'black')
                        
                        plt.xlabel('Predicted Label')
                        plt.ylabel('True Label')
                    
                    trained_model = model
                    
                else:  # clustering
                    features_clean = [col.strip() for col in feature_columns]
                    X = df[features_clean]
                    X_processed = X.copy()
                    
                    # Handle categorical variables and missing values
                    for col in X_processed.columns:
                        if X_processed[col].dtype == 'object':
                            le = LabelEncoder()
                            X_processed[col] = le.fit_transform(X_processed[col].astype(str))
                        else:
                            X_processed[col] = pd.to_numeric(X_processed[col], errors='coerce').fillna(X_processed[col].median())
                    
                    # Standardize features
                    scaler = StandardScaler()
                    X_scaled = scaler.fit_transform(X_processed)
                    
                    # Determine number of clusters
                    if cluster_method == 'manual' and num_clusters is not None:
                        # Use manually specified number of clusters
                        n_clusters = int(num_clusters)
                        print(f"Using manual cluster count: {n_clusters}")
                    else:
                        # Use automatic elbow method
                        n_clusters = 3  # Default
                        if len(X_scaled) > 10:
                            inertias = []
                            k_range = range(2, min(8, len(X_scaled)//2))
                            for k in k_range:
                                kmeans_temp = KMeans(n_clusters=k, random_state=42, n_init=10)
                                kmeans_temp.fit(X_scaled)
                                inertias.append(kmeans_temp.inertia_)
                            
                            # Simple elbow detection
                            if len(inertias) > 2:
                                changes = [inertias[i] - inertias[i+1] for i in range(len(inertias)-1)]
                                for i in range(1, len(changes)):
                                    if changes[i] < changes[i-1] * 0.3:
                                        n_clusters = k_range[i]
                                        break
                        print(f"Using automatic cluster detection: {n_clusters}")
                    
                    # Train K-means
                    model = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
                    labels = model.fit_predict(X_scaled)
                    
                    # Store scaler for clustering predictions
                    model_scaler = scaler
                    
                    # Calculate clustering metrics
                    silhouette_avg = silhouette_score(X_scaled, labels) if len(set(labels)) > 1 else 0
                    metrics = {
                        'silhouette_score': round(silhouette_avg, 3),
                        'num_clusters': n_clusters,
                        'inertia': round(model.inertia_, 3)
                    }
                    
                    # Create clustering visualization
                    plt.figure(figsize=(10, 8))
                    
                    if X_scaled.shape[1] > 2:
                        # Use PCA for dimensionality reduction
                        pca = PCA(n_components=2, random_state=42)
                        X_2d = pca.fit_transform(X_scaled)
                        centers_2d = pca.transform(model.cluster_centers_)
                        plt.title('Clustering Results (PCA 2D Projection)')
                    else:
                        X_2d = X_scaled
                        centers_2d = model.cluster_centers_
                        plt.title('Clustering Results')
                    
                    # Plot points with different colors for each cluster
                    colors = plt.cm.Set3(np.linspace(0, 1, n_clusters))
                    for i in range(n_clusters):
                        cluster_points = X_2d[labels == i]
                        plt.scatter(cluster_points[:, 0], cluster_points[:, 1], 
                                   c=[colors[i]], label=f'Cluster {i}', alpha=0.7, s=60)
                    
                    # Plot cluster centers
                    plt.scatter(centers_2d[:, 0], centers_2d[:, 1], 
                               c='red', marker='x', s=200, linewidths=3, label='Centroids')
                    
                    plt.legend()
                    plt.grid(True, alpha=0.3)
                    
                    trained_model = model
                
                # Save plot as base64 image
                buffer = io.BytesIO()
                plt.savefig(buffer, format='png', dpi=150, bbox_inches='tight')
                buffer.seek(0)
                image_png = buffer.getvalue()
                buffer.close()
                
                graphic = base64.b64encode(image_png).decode('utf-8')
                
                # Display the plot
                chart_container = js.document.getElementById('training-chart')
                if chart_container:
                    img_element = js.document.createElement('img')
                    img_element.src = 'data:image/png;base64,' + graphic
                    img_element.style.maxWidth = '100%'
                    img_element.style.height = 'auto'
                    chart_container.innerHTML = ''
                    chart_container.appendChild(img_element)
                
                plt.close()
                
                # Store model info globally
                global model_info
                model_info = {
                    'type': model_type,
                    'target': target_column,
                    'features': feature_columns,
                    'rows': df.shape[0],
                    'train_split': train_split,
                    'metrics': metrics,
                    'scaler': model_scaler if model_type == 'clustering' else None
                }
                
                print(f"‚úì Model training completed with metrics: {metrics}")
                
                result = {
                    'success': True,
                    'message': f'{model_type} model trained successfully!',
                    'rows': df.shape[0],
                    'features': len(feature_columns),
                    'metrics': metrics
                }
                
                return json.dumps(result)
                
            except Exception as e:
                print(f"‚ùå Training error: {e}")
                import traceback
                traceback.print_exc()
                error_result = {'success': False, 'error': str(e)}
                return json.dumps(error_result)
        
        def make_prediction_simple(feature_values_json):
            import json
            global trained_model, model_info
            print("Making prediction...")
            print(f"Feature values JSON: {feature_values_json}")
            print(f"Feature values JSON type: {type(feature_values_json)}")
            
            # Parse the JSON string to get feature values
            try:
                if isinstance(feature_values_json, str):
                    feature_values = json.loads(feature_values_json)
                else:
                    feature_values = feature_values_json
            except Exception as e:
                return json.dumps({'success': False, 'error': f'Failed to parse feature values JSON: {e}'})
            
            print(f"Feature values after parsing: {feature_values}")
            print(f"Trained model exists: {trained_model is not None}")
            print(f"Model info: {model_info}")
            
            if trained_model is None:
                return json.dumps({'success': False, 'error': 'No trained model available'})
            
            if not model_info:
                return json.dumps({'success': False, 'error': 'Model info not available'})
            
            try:
                # Convert feature values to the format used during training
                import numpy as np
                
                # Extract feature values in the correct order
                feature_list = []
                model_features = model_info.get('features', [])
                print(f"Expected features: {model_features}")
                
                for feature in model_features:
                    value = feature_values.get(feature, 0)
                    # Convert to numeric
                    try:
                        numeric_value = float(value)
                    except:
                        numeric_value = 0.0
                    feature_list.append(numeric_value)
                
                print(f"Feature values for prediction: {feature_list}")
                
                # Create a DataFrame with proper feature names for prediction
                import pandas as pd
                prediction_data = pd.DataFrame([feature_list], columns=model_features)
                print(f"Prediction DataFrame: {prediction_data}")
                
                # Make prediction with the actual trained model
                model_type = model_info.get('type', '')
                if model_type == 'clustering':
                    # For clustering, apply the same scaling used during training
                    scaler = model_info.get('scaler')
                    if scaler:
                        prediction_data_scaled = scaler.transform(prediction_data)
                        prediction = trained_model.predict(prediction_data_scaled)[0]
                    else:
                        prediction = trained_model.predict(prediction_data)[0]
                    result = int(prediction)
                else:
                    # For regression/classification
                    prediction = trained_model.predict(prediction_data)[0]
                    if model_type == 'regression':
                        result = round(float(prediction), 2)
                    else:
                        result = int(prediction)
                
                print(f"‚úì Prediction: {result}")
                return json.dumps({'success': True, 'prediction': result})
                
            except Exception as e:
                print(f"‚ùå Prediction error: {e}")
                import traceback
                traceback.print_exc()
                return json.dumps({'success': False, 'error': str(e)})
        
        def save_trained_model():
            import json
            import pickle
            import base64
            from io import BytesIO
            import copy
            
            try:
                if 'trained_model' not in globals() or trained_model is None:
                    return json.dumps({"success": False, "error": "No trained model available"})
                
                # Create a clean model package with only serializable components
                model_package = {}
                
                # Create a clean copy of the trained model to avoid JsProxy issues
                # We'll recreate the model with just the essential parameters
                clean_model = None
                
                if hasattr(trained_model, '__class__'):
                    model_class = trained_model.__class__
                    
                    if hasattr(trained_model, 'get_params'):
                        # For sklearn models, get parameters and recreate
                        params = trained_model.get_params()
                        clean_params = {}
                        
                        # Filter out non-serializable parameters
                        for key, value in params.items():
                            if isinstance(value, (str, int, float, bool, type(None))) or \
                               (hasattr(value, '__module__') and 'sklearn' in str(value.__module__)):
                                clean_params[key] = value
                        
                        # Create new instance with clean parameters
                        clean_model = model_class(**clean_params)
                        
                        # Copy the fitted attributes
                        for attr in dir(trained_model):
                            if attr.endswith('_') and not attr.startswith('_'):
                                try:
                                    attr_value = getattr(trained_model, attr)
                                    # Test if attribute is serializable
                                    pickle.dumps(attr_value)
                                    setattr(clean_model, attr, attr_value)
                                except:
                                    # Skip non-serializable attributes
                                    pass
                    else:
                        # Fallback: try to use the original model
                        clean_model = trained_model
                else:
                    clean_model = trained_model
                
                model_package['model'] = clean_model
                
                # Add scaler if it exists (for clustering)
                if 'model_scaler' in globals() and model_scaler is not None:
                    model_package['scaler'] = model_scaler
                else:
                    model_package['scaler'] = None
                
                # Clean model_info to remove any JsProxy objects
                clean_model_info = {}
                if 'model_info' in globals() and model_info and isinstance(model_info, dict):
                    for key, value in model_info.items():
                        # Only include basic Python types
                        if isinstance(value, (str, int, float, bool, list, dict, type(None))):
                            try:
                                # Test if the value is serializable
                                pickle.dumps(value)
                                clean_model_info[key] = value
                            except:
                                # Skip non-serializable values
                                pass
                
                model_package['model_info'] = clean_model_info if clean_model_info else None
                
                # Test each component individually to isolate the problem
                try:
                    pickle.dumps(model_package['model'])
                except Exception as model_error:
                    return json.dumps({"success": False, "error": f"Model serialization failed: {str(model_error)}"})
                
                try:
                    pickle.dumps(model_package['scaler'])
                except Exception as scaler_error:
                    return json.dumps({"success": False, "error": f"Scaler serialization failed: {str(scaler_error)}"})
                
                try:
                    pickle.dumps(model_package['model_info'])
                except Exception as info_error:
                    return json.dumps({"success": False, "error": f"Model info serialization failed: {str(info_error)}"})
                
                # If all components pass, serialize the complete package
                model_buffer = BytesIO()
                pickle.dump(model_package, model_buffer)
                model_bytes = model_buffer.getvalue()
                
                # Encode to base64 for safe transfer
                model_base64 = base64.b64encode(model_bytes).decode('utf-8')
                
                return json.dumps({
                    "success": True,
                    "model_data": model_base64
                })
                
            except Exception as e:
                import traceback
                error_details = f"{str(e)}\n{traceback.format_exc()}"
                return json.dumps({"success": False, "error": error_details})
        
        # Make functions available to JavaScript
        js.window.pyTrainModel = train_model_simple
        js.window.pyMakePrediction = make_prediction_simple
        js.window.pySaveModel = save_trained_model
        
        # Set ready flag
        js.window.pyScriptReady = True
        print("‚úì PyScript ready flag set")
        
        print("PyScript initialization complete")
    </py-script>

    <script>
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });
    </script>
</body>
</html>