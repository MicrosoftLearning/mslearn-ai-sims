document.addEventListener('DOMContentLoaded', ()=>{
  const captions = {
    'image1': 'A giraffe standing in a field',
    'image2': 'An elephant with tusks in a field',
    'image3': 'A lion in a field of tall grass',
    'image4': 'A zebra standing on the side of a road'
  };

  // mapping of suggested tags per image base name
  const suggestedTagsMap = {
    'image1': ['animal','outdoor','giraffe','savannah','safari'],
    'image2': ['animal','outdoor','elephant','tusk','safari'],
    'image3': ['animal','outdoor','lion','bigcat','safari'],
    'image4': ['animal','outdoor','zebra','text','safari']
  };

  const uploadBtn = document.getElementById('upload-btn');
  const dialog = document.getElementById('file-dialog');
  const fileList = document.getElementById('file-list');
  const dialogClose = document.getElementById('dialog-close');
  const dialogCancel = document.getElementById('dialog-cancel');
  const dialogOpen = document.getElementById('dialog-open');
  const fileNameInput = document.getElementById('file-name');

  const preview = document.getElementById('preview');
  const previewImg = document.getElementById('preview-img');
  const captionEl = document.getElementById('caption');
  const disclaimer = document.getElementById('disclaimer');

  let selectedItem = null;
  let selectedFile = null;

  // Timers for analyzing and typing so we can cancel if user loads another image quickly
  let analyzeTimeout = null;
  let typingInterval = null;

  // Given an array of filenames, pick one per base name using a preferred extension order
  function pickPreferredFiles(candidates){
    const order = ['png','jpg','jpeg','webp','gif','svg'];
    const groups = {};
    candidates.forEach(fn => {
      const m = fn.match(/\.([^.]+)$/);
      const ext = m ? m[1].toLowerCase() : '';
      const base = fn.replace(/\.[^/.]+$/, '');
      if(!groups[base]) groups[base] = [];
      groups[base].push({fn, ext});
    });

    return Object.keys(groups).sort().map(base => {
      const items = groups[base];
      for(const pref of order){
        const found = items.find(i => i.ext === pref);
        if(found) return found.fn;
      }
      return items[0].fn;
    });
  }

  // Try to fetch the directory listing generated by the static server and parse it for files
  function listImagesFromFolder(){
    return fetch('images/')
      .then(res => {
        if(!res.ok) throw new Error('Unable to fetch images directory');
        return res.text();
      })
      .then(html => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const anchors = Array.from(doc.querySelectorAll('a'));
        const candidates = anchors
          .map(a => a.getAttribute('href'))
          .filter(h => h && h !== '../' && h !== '/' && !h.endsWith('/'))
          .filter(h => /\.(svg|png|jpg|jpeg|gif|webp)$/i.test(h));

        // pick preferred files when both svg and jpg exist with same base name
        return pickPreferredFiles(candidates);
      });
  }

  function setSelectionElement(li){
    if(selectedItem) { selectedItem.classList.remove('selected'); selectedItem.removeAttribute('aria-selected'); }
    selectedItem = li;
    selectedFile = li ? li.dataset.filename : null;
    if(li){ li.classList.add('selected'); li.setAttribute('aria-selected','true'); fileNameInput.value = selectedFile; dialogOpen.disabled = false; }
    else { fileNameInput.value = ''; dialogOpen.disabled = true; }
  }

  function focusNext(li, direction){
    const next = direction === 1 ? li.nextElementSibling : li.previousElementSibling;
    if(next){ next.focus(); setSelectionElement(next); }
  }

  async function openDialog(){
    fileList.innerHTML = '';
    setSelectionElement(null);

    let imgFiles = [];
    try{ imgFiles = await listImagesFromFolder(); } catch(e){ imgFiles = ['image1.jpg','image2.jpg','image3.jpg','image4.jpg']; }

    imgFiles.forEach(fn => {
      const li = document.createElement('li');
      li.className = 'file-item';
      li.setAttribute('role','option');
      li.tabIndex = 0;
      li.dataset.filename = fn;

      const src = `images/${fn}`;
      li.innerHTML = `\
        <img class="thumb" src="${src}" alt="">\
        <div class="meta">\
          <div class="name">${fn}</div>\
        </div>`;

      li.addEventListener('click', ()=> setSelectionElement(li));
      li.addEventListener('dblclick', ()=> { setSelectionElement(li); openSelected(); });
      li.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ e.preventDefault(); openSelected(); }
        else if(e.key === ' '){ e.preventDefault(); setSelectionElement(li); }
        else if(e.key === 'ArrowDown'){ e.preventDefault(); focusNext(li, 1); }
        else if(e.key === 'ArrowUp'){ e.preventDefault(); focusNext(li, -1); }
      });

      fileList.appendChild(li);
    });

    const first = fileList.querySelector('.file-item');
    if(first) { first.focus(); setSelectionElement(first); }
    dialog.hidden = false;
  }

  function openSelected(){ if(selectedFile) loadFile(selectedFile); }

  function clearPendingTimers(){
    if(analyzeTimeout){ clearTimeout(analyzeTimeout); analyzeTimeout = null; }
    if(typingInterval){ clearInterval(typingInterval); typingInterval = null; }
    captionEl.classList.remove('typing');
    removeSuggestedTags();
    removeDetectedText();
  }

  function typeCaption(text, charDelay = 40){
    captionEl.textContent = '';
    captionEl.classList.add('typing');
    let i = 0;
    typingInterval = setInterval(() => {
      captionEl.textContent += text.charAt(i);
      i++;
      if(i >= text.length){
        clearInterval(typingInterval);
        typingInterval = null;
        captionEl.classList.remove('typing');
        // show suggested tags button after caption has been fully typed
        createSuggestedTagsButton();
        // show any detected text (if present for this image)
        createDetectedTextDisplay();
      }
    }, charDelay);
  }

  // mapping of detected text per image (simulated OCR results)
  const detectedTextMap = {
    'image4': 'SAFARI\nLODGE\n2 MILES'
  };

  // helper functions to manage the suggested tags UI
  function removeSuggestedTags(){
    const wrap = document.getElementById('suggested-tags-wrap');
    if(wrap && wrap.parentNode) wrap.parentNode.removeChild(wrap);
    const oldBtn = document.getElementById('suggested-tags-btn');
    if(oldBtn && oldBtn.parentNode) oldBtn.parentNode.removeChild(oldBtn);
  }

  // helper to remove detected text UI
  function removeDetectedText(){
    const existing = document.getElementById('detected-text');
    if(existing && existing.parentNode) existing.parentNode.removeChild(existing);
  }

  function populateSuggestedTags(){
    const listEl = document.getElementById('suggested-tags-list');
    if(!listEl) return;

    // determine base name from selectedFile or preview image alt/src
    let base = selectedFile || previewImg.alt || '';
    if(!base && previewImg.src){
      const m = previewImg.src.match(/\/([^\/\?#]+)(?:[?#].*)?$/);
      base = m ? m[1] : '';
    }
    base = base.replace(/\.[^/.]+$/, '');

    const tags = suggestedTagsMap[base] || [];
    listEl.innerHTML = '';
    tags.forEach(t => {
      const span = document.createElement('span');
      span.className = 'tag-badge';
      span.textContent = t;
      listEl.appendChild(span);
    });
    if(tags.length === 0) listEl.textContent = 'No tags';
  }

  function createSuggestedTagsButton(){
    removeSuggestedTags();
    removeDetectedText();
    const wrap = document.createElement('div');
    wrap.id = 'suggested-tags-wrap';
    wrap.className = 'suggested-tags-wrap';

    const btn = document.createElement('button');
    btn.id = 'suggested-tags-btn';
    btn.type = 'button';
    btn.className = 'suggested-tags';
    btn.textContent = 'Suggested tags';
    btn.setAttribute('aria-label','Show suggested tags');

    const listEl = document.createElement('div');
    listEl.id = 'suggested-tags-list';
    listEl.className = 'suggested-tags-list';
    listEl.setAttribute('aria-live','polite');
    listEl.style.display = 'none';

    btn.addEventListener('click', ()=> {
      if(listEl.style.display === 'none' || getComputedStyle(listEl).display === 'none'){
        populateSuggestedTags();
        listEl.style.display = 'flex';
      } else {
        listEl.style.display = 'none';
      }
    });

    wrap.appendChild(btn);
    wrap.appendChild(listEl);
    captionEl.insertAdjacentElement('afterend', wrap);
    return btn;
  }

  // create and insert the detected text UI when OCR results are available
  function createDetectedTextDisplay(){
    removeDetectedText();

    // determine base name from selectedFile or preview image alt/src
    let base = selectedFile || previewImg.alt || '';
    if(!base && previewImg.src){
      const m = previewImg.src.match(/\/([^\/\?#]+)(?:[?#].*)?$/);
      base = m ? m[1] : '';
    }
    base = base.replace(/\.[^/.]+$/, '');

    const text = detectedTextMap[base];
    if(!text) return;

    const container = document.createElement('div');
    container.id = 'detected-text';
    container.className = 'detected-text';

    const label = document.createElement('div');
    label.className = 'detected-text-label';
    label.textContent = 'Text detected:';

    const pre = document.createElement('pre');
    pre.className = 'detected-text-pre';
    pre.textContent = text;

    container.appendChild(label);
    container.appendChild(pre);

    const wrap = document.getElementById('suggested-tags-wrap');
    // insert the detected text above the suggested-tags button (before the wrap)
    if(wrap && wrap.parentNode) wrap.insertAdjacentElement('beforebegin', container);
    else captionEl.insertAdjacentElement('afterend', container);
  }

  function loadFile(filename){
    // cancel any pending analyze/typing from previous image
    clearPendingTimers();

    // ensure we wait until the image is loaded before showing preview and running analysis
    previewImg.onload = () => {
      preview.hidden = false;
      disclaimer.hidden = false;

      // show analyzing message for 3 seconds, then type the caption
      captionEl.classList.remove('typing');
      captionEl.textContent = 'Analyzing image...';

      analyzeTimeout = setTimeout(() => {
        analyzeTimeout = null;
        const base = filename.replace(/\.[^/.]+$/, '');
        const finalCaption = captions[base] || 'No caption available';
        typeCaption(finalCaption, 40);
      }, 3000);
    };

    previewImg.onerror = () => {
      clearPendingTimers();
      preview.hidden = false;
      disclaimer.hidden = false;
      captionEl.textContent = 'Unable to load image';
      removeSuggestedTags();
      removeDetectedText();
    };

    previewImg.src = `images/${filename}`;
    previewImg.alt = filename;
    closeDialog();
  }

  function closeDialog(){ dialog.hidden = true; }

  uploadBtn.addEventListener('click', openDialog);
  dialogClose.addEventListener('click', closeDialog);
  dialogCancel.addEventListener('click', closeDialog);
  dialogOpen.addEventListener('click', openSelected);

  dialog.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeDialog(); });
  dialog.addEventListener('click', (e)=>{ if(e.target === dialog) closeDialog(); });

});
